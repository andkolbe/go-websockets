package main

import (
	"fmt"
	"net/http"

	"github.com/andkolbe/go-websockets/internal/helpers"
	"github.com/justinas/nosurf"
)

// adds CSRF protection to all POST requests
func NoSurf(next http.Handler) http.Handler {
	csrfHandler := nosurf.New(next)

	// uses cookies to make sure the token it generates for us is on a per page basis
	csrfHandler.SetBaseCookie(http.Cookie{
		HttpOnly: true,
		Path:     "/",              // "/" means apply this cookie to the entire site
		Secure:   app.InProduction, 
		SameSite: http.SameSiteLaxMode,
	})

	return csrfHandler
}

// webservers are not state aware, so we need to add middleware that tells this application to remember state using sessions
// loads and saves the session on every request
func SessionLoad(next http.Handler) http.Handler {
	return session.LoadAndSave(next)
}

// Auth checks for authentication
func Auth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !app.Session.Exists(r.Context(), "userID") {
			
			http.Redirect(w, r, "/", http.StatusSeeOther)
			return
		}
		w.Header().Add("Cache-Control", "no-store")

		next.ServeHTTP(w, r)
	})
}

// RecoverPanic recovers from a panic
func RecoverPanic(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			// Check if there has been a panic
			if err := recover(); err != nil {
				// return a 500 Internal Server response
				helpers.ServerError(w, r, fmt.Errorf("%s", err))
			}
		}()
		next.ServeHTTP(w, r)
	})
}


/*
	What are CSRF Tokens?
	
	A CSRF token is a unique, secret, unpredictable value that is generated by the server side app and transmitted to the client in such a way that it is 
	included in a subsequent HTTP request made by the client. When the later request is made, the server side app validates that the request includes the
	expected token and rejects the request if the token is missing or invalid 

	CSRF tokens can prevent CSRF attacks by making it impossible for an attacker to construct a fully valid HTTP request suitable for feeding to a victim user.
	Since the attacker cannot determine or predict the value of a user's CSRF token, they cannot construct a request with all the parameters that are necessary
	for the app to honor the request

	CSRF tokens should contain significant entropy and be strongly unpredictable, with the same properties as session tokens in general 

	CSRF tokens should be treated as secrets and handled in a secure manner throughout their lifecycle. An approach that is normally effective is to transmit
	the token to the client within a hidden field of an HTML form that is submitted using the POST method. The token will then be included as a request parameter
	when the form is submitted

	For additional safety, the field containing the CSRF token should be placed as early as possible within the HTML document, ideally before any non hidden
	input fields and before any locations where user controllable data is embedded within the HTML. This mitigates against various techniques in which an
	attacker can use crafted data to manipulate the HTML document and capture parts of its contents

*/